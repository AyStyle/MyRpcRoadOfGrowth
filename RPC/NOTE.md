# 1. 分布式理论
## 1.分布式系统架构
### 1.分布式系统概念
```text
   分布式系统是一个硬件或软件组件分布在不同的网络计算机上，
批次之间仅仅通过消息传递进行通信和协调的系统。
```
集群：多个人在一起做同样的事。
分布式：多个人在一起做不同的事。

##### 分布式系统的特点
1. 分布性 
2. 对等性
3. 并发性
4. 缺乏全局时钟
5. 故障总会发生

### 2.分布式系统发展
```text
    去除IOE，I：IBM小型机，O：Oracle数据库，E：EMC高端存储
```
##### 为什么要去IOE？
1. 升级单机处理能力的性价比越来越低。
2. 单机处理能力存在瓶颈。
3. 稳定性和可用性这两个指标很难达到。

### 3.分布式架构的演变
阶段一：单应用架构
阶段二：应用服务器与数据库服务器分离
阶段三：应用服务器集群
阶段四：应用服务器负载客户
阶段五：数据库读写分离
阶段六：添加搜索引擎缓解读库压力
阶段七：添加缓存机制缓解数据库的压力
阶段八：数据库水平/垂直拆分
阶段九：应用拆分
阶段十：服务化

## 2.分布式系统面临的问题
1. 通信异常
   ```text
      网络本身的不可靠性，因此每次网络通信都会伴随着网络不可用的风险
   （光纤、路由、DNS等硬件设备或系统的可不用），都会导致最终分布式系
   统无法顺利进行一次网络通信，另外，即使分布式系统各节点之间的网络通
   信能够正常执行，其延时也会大于单机操作，存在巨大的延迟差别，也会影
   响消息的收发过程，因此消息丢失和消息延迟变得非常普遍。
   ```
2. 网络分区
   ```text
      网络之间出现了网络不连通，但各个子网络内部网络是正常的，从而导致
   整个系统的网络环境被切分成了若干个孤立的区域，分布式系统就会出现局部
   小集群，在极端情况下，这些小集群会独立完成原本需要整个分布式系统才能
   完成的功能，包括数据的事务处理，这就对分布式一致性提出非常大的挑战。
   ```
3. 节点故障
   ```text
      节点故障指的是组成分布式系统的服务器节点出现宕机或僵死的现象，
   根据经验来说，每个节点都有可能出现故障，并且经常发生。
   ```
4. 三态
   ```text
      分布式系统每一次请求与响应存在特有的“三态”概念：成功、失败、超时。
   分布式系统中，由于网络是不可靠的，虽然绝大部分情况下，网络通信能够接
   受到成功或失败的响应，但当网络出现异常的情况下，就会出现超时现象，通
   常有以下两种情况：   
       1. 由于网络原因，该请求并没有被成功的发送到接受方，而是在发送过
          程中发生了丢包现象。
       2. 该请求成功的被接收方接手后，并进行了处理，但在响应反馈给发送
          方过程中，发生了消息丢包现象。
   ```

## 3. 分布式理论：一致性
### 1. 什么是分布式一致性
```text
分布式数据一致性，指的是数据在多份副本中存储时，各副本中的数据是一致的。
```
### 2. 副本一致性
```text
分布式系统有多态机器，每台机器上的数据就是一个副本，集群中每台机器的数据
一致就是副本一致性。
```
### 3. 一致性分类
1. 强一致性
   ```text
   这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也是什么，
   用户体验好，但实现起来往往对系统的性能影响大且很难实现
   ```
2. 弱一致性
   ```text
   这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的数据，也不
   承诺多久之后数据能够到达一致，但会尽可能地保证到某个时间级别（比如秒级）
   后，数据能够达到一致状态。
   ``` 
   1. 读写一致性      
      ```text
      用户读取自己写入结果的一致性，保证用户永远能够第一时间看到自己更像的
      内容。
      
      解决方案：
          1. 对于一些特定的内容我们每次都去主库读取。（导致主库压力大）
          2. 设置一个更新时间窗口，在刚刚更新的一段时间内，我们默认都从主库
             读取，过了这个窗口之后，我们会挑选最近有过更新的从库进行读取。
          3. 我们直接记录用户更新的时间戳，在请求的时候把这个时间戳带上，
             凡是最后更新时间小于这个时间撮的从库都不予响应。
      ```
   2. 单调读一致性
      ```text
      本次读到的数据不能比上次读到的旧。
      由于主从节点更新数据的时间不一致，导致用户在不停刷新的时候，有时候能刷出来，
      再次刷新之后会发现数据不见了，再刷新又有可能再刷出来。
      
      解决方案：
         就是根据用户id计算一个hash值，再通过hash值映射到机器。同一个用户不管怎么
         刷新，都只会被映射到同一台机器上，这样就保证了不会读到其他从库的内容，带来
         用户体验不好的影响。
      ```   
   3. 因果一致性
      ```text
      指的是：如果节点A在更新完某个数据后通知了节点B，那么节点B之后对该数据的访问和
      修改都是基于A更新后的值。与此同时，和节点A无因果关系的节点C的数据访问则没有这
      样的限制。
      ```   
   4. 最终一致性
      ```text
      最终一致性是所有分布式一致性模型中最弱的。可以认为是没有任何优化的“最”弱一致性
      它的意思是说，不考虑所有的中间状态的影响，只保证当没有新的更新之后，经过一段时
      间之后，最终系统内所有副本的数据都是正确的。它最大程度上保证了系统的并发能力，
      也因此，在高并发的场景下，它也是使用最广的一致性模型。
      ```
## 4. 分布式理论：CAP定理
CAP定理
```text
CAP理论含义是，一个分布式系统不可能同时满足一致性（C：Consistency），可用性
（A：Availability）和分区容错性（P：Partition tolerance）这三个基本需求，
最多同时满足其中的两个。
C一致性（Consistency）：分布式系统当中的一致性指的是所有节点的数据一致，或者说是所有副本的数据一致，这种一致性是强一致性
A可用性（Availability）：Reads and writes always succeed。也就是说系统一直可用，而且服务一直保持正常
P分区容错性（Partition tolerance）：系统在遇到一些节点或者网络分区故障的时候，仍然能够提供满足一致性和可用性的服务
```      
      
## 5. 分布式理论：BASE理论
```text
BASE全称是Basically Available（基本可用），Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。
BASE是对CAP中一致性和可用性权衡的结果，BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当
的方式来使系统达到最终一致性。
```
1. Basically Available（基本可用）
   ```text
   基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性--但请注意，这绝不等价于系统不可用。以下有两个例子：
      1.响应时间上的损失：正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，
        查询结果的响应时间增加到1~2秒。
      2.功能上的损失：正常情况下，在一个电子商务网站上购物，消费者几乎能够顺利地完成每一笔订单。但在一些节日大促购物高峰
        的时候，由于消费者的购物行为激增，为了保护系统的稳定性（或一致性），部分消费者可能会被引导到一个降级页面。 
   ```
2. Soft state（软状态）
   ```text
   软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，
   即允许系统在多个不同节点的数据副本之间进行数据同步的过程中存在延迟。
   ```
3. Eventually consistent（最终一致性）
   ```text
   最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此最终一致性的本质是
   需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。
   ```
   
## 6. 分布式理论：一致性协议2PC
### 1，什么是2PC
```text
2PC（Two-Phase Commit缩写）即两个阶段提交协议，是将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段
（commit phase），2是指两个阶段，P是指准备阶段，C是指提交阶段。
```
1. 准备阶段（Prepare phase）
   ```text
   事务管理器给每个参与者发送Prepare消息，每个数据库参与者在本地执行事务，并写本地的Undo/Redo日志，此时事务没有提交。
   （Undo日志是记录修改前的数据，用于数据库回滚，Redo日志是记录修改后的数据，用于提交事务后写入数据文件）
   ```
2. 提交阶段（Commit phase）
   ```text
   如果事务管理器收到了参与者的执行失败或超时消息时，直接给每个参与者发送回滚（Rollback）消息；否则，发送（Commit）消息；
   参与者根据事务管理器的指令执行提交或回滚操作，并释放事务处理过程中使用的所资源。注意：必须在最后阶段释放所资源。
   ```
   
## 7. 分布式理论：一致性协议3PC
```text
3PC，全称“three phase commit”，是2PC的改进版，将2PC的“提交事务请求”过程一分为二，形成了
CanCommit、PreCommit和DoCommit三个阶段组成的事务处理协议。
```
1. 阶段一：CanCommit
2. 阶段二：PreCommit
3. 阶段三：DoCommit

## 8. 分布式理论：一致性算法Paxos
1. Paxos相关概念
   ```text
    首先一个很重要的概念叫提案（Proposal）。最终要达成一致的value就在提案里。
    提案（Proposal）：
       Proposal信息包括提案编号（Proposal ID）和提议的值（Value）
    
    在Paxos算法中，有如下角色：
       Client：客户端
          客户端向分布式系统发出请求，并等待响应。例如，对分布式文件服务器中文件的写请求。
    
       Proposer：提案发起者
          提案者提倡客户请求，试图说服Acceptor对此达成一致，并在发生冲突时充当协调者以推动协议向前发展
    
       Acceptor：决策者，可以批准提案
          Acceptor可以接受提案；如果某个提案被选定，那么提案里的value就被选定了
    
       Learners：最终决策的学习者
          学习者充当该协议的复制因素
    ```
2. Paxos算法的几点要求：
   ```text
    假设有一组可以提出提案的进程集合，那么对于一个一致性算法需要保证以下几点：
       1. 在这些被提出的提案中，只有一个会被选定
       2. 如果没有提案被提出，就不应该有被选定的提案
       3. 当一个提案被选定后，那么所有进程都应该能学习到这个被选定的value
   ```
   
3. Paxos算法的规定
   1. 一个Acceptor必须接受它收到的第一个提案
   2. 一个提案被选定必须被半数以上的Acceptor接受
   3. 如果某个value为v的提案被选定了，那么每个编号更高的被选定的提案value必须也是v
   4. 如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案value必须也是v
   5. 如果某个value为v的提案被选定了，那么之后任何Proposer提出的编号更高的提案value必须也是v
   6. 对于任意的Mn和Vn，如果提案[Mn,Vn]被提出，那么肯定存在一个由半数以上的Acceptor组成的集合S，满足以下两个条件的任意一个：
      + S中每个Acceptor都没有接受过编号小于Mn的提案（少见）
      + S中每个Acceptor批准的所有编号小于Mn的提案中，编号最大的那个提案的value为Vn
      
4. Paxos算法提案生成的规则
   + Proposer生成提案:
       ```text
       1. Proposer选择一个新的提案编号N，然后向某个Acceptor集合（半数以上）发送请求，要求该
          集合中的每个Acceptor做出如下响应（response）：
          a. Acceptor向Proposer承诺保证不再接受任何小于N的提案。
          b. 如果Acceptor已经接受过提案，那么就向Proposer反馈已经接受过的编号小于N的，
             但为最大编号的提案的值。
     
       2. 如果Proposer收到了半数以上的Acceptor响应，那么它就可以生成编号为N，Value为V的提案[N,V]。
          这里的V是所有响应中编号最大的提案的Value。如果所有响应都没有提案，那么此时V就可以由Proposer
          自己选择。生成提案后，Proposer将该提案发送给半数以上的Acceptor集合，并期望Acceptor能够接受该提案。
       
       注：1称之为编号为N的Prepare请求，2称之为Accept请求。     
       ```
     
   + Acceptor接受提案：
      ```text
      1. Prepare请求：Acceptor可以在任何时候响应一个Prepare请求
      2. Accept请求： 在不违背Accept现有承若的前提下，可以任意响应Accept请求
     
      约束：
         一个Acceptor只要尚未响应过任何编号大于N的Prepare请求，那么它就可以接受这个编号为N的提案
      ```
5. Learn学习被选定的value
   1. 方案一：
      ```text
      Acceptor接受一个提案，就将该提案发送给所有Learner。
      
      优点：Learner能快速获取被选定的value
      缺点：通信次数为M*N
      ```     
   2. 方案二：
      ```text
      Acceptor接受了一个提案，就将该提案发送给主Learner，主Learner再通知其他Learner
      
      优点：通信次数少M+N-1
      缺点：单点问题，主Learner挂了，则无法同步提案
      ```
      
   3. 方案三：
      ```text
      Acceptor接受一个提案，就将该提案发送给一个Learner集合，Learner集合再通知其他Learner
      
      优点：集合中Learner个数越多，可靠性越好
      缺点：网络通信复杂度高
      ```
      
6. 保证Paxos算法活性
   ```text
   活性：最终一定会发生的事情，最终一定要选定value
   方案：选取一个住Proposer，只有主Proposer才能提出提案
   ```
   
## 9.分布式理论：一致性算法Raft
```text
Raft是一种为了管理复制日志的一致性算法。
Raft提供了和Paxos算法相同的功能和特性，但是它的算法结构和Paxos不同。
Raft算法更加容易理解并且更容易构建实际的系统。

Raft将一致性算法分为三个模块：
   1.领导人选举
   2.日志复制
   3.安全性

Raft算法分为两个阶段：
   1.先选举领导人
   2.在领导人的带领下进行操作
```
1. 领导人选举
   ```text
   在Raft中，任何时候一台服务器都可以扮演下面角色的其中之一：
      1. 领导者（leader）：处理客户端交互，日志复制等动作，一般一次只有一个领导者
      2. 候选者（candidate）：候选者就是在选举过程中提名自己的实体，一旦选举成功，则成为领导者
      3. 跟随者（follower）：类似选民，完全被动的角色，这样的服务器等待被通知投票，而影响它们身份变化的则是选举
   
   Raft使用心跳机制来触发选举。当Server启动时，初始状态都是follower。每一个server都有一个定时器，
   超时时间为election timeout（150-300ms），如果某个Server没有超时的情况下收到来自领导者或候选者
   的任何消息，则：定时器重启，否则：它就开始一次选举
   ```
   
2. 节点异常
   1. leader不可用：重新选举leader，如果旧leader变的可用，则：旧leader同步数据并变为follower
   2. follower节点不可用或添加follower机器：同步leader数据，然后正常工作
   3. 多个candidate或多个leader：多次投票选举，直到选举出leader为止
   
   
# 2.分布式系统设计策略
1. 心跳检测
2. 高可用设计
3. 容错性
4. 负载均衡 

# 3.RPC
### 1. 什么是RPC
```text
RPC全称为Remote Procedure Call，即远程过程调用。
借助RPC可以做到像本地调用一样调用远程服务，是一种进程间的通信方式。
需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。
```