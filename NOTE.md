# 1. 分布式理论
## 1.分布式系统架构
### 1.分布式系统概念
```text
   分布式系统是一个硬件或软件组件分布在不同的网络计算机上，
批次之间仅仅通过消息传递进行通信和协调的系统。
```
集群：多个人在一起做同样的事。
分布式：多个人在一起做不同的事。

##### 分布式系统的特点
1. 分布性 
2. 对等性
3. 并发性
4. 缺乏全局时钟
5. 故障总会发生

### 2.分布式系统发展
```text
    去除IOE，I：IBM小型机，O：Oracle数据库，E：EMC高端存储
```
##### 为什么要去IOE？
1. 升级单机处理能力的性价比越来越低。
2. 单机处理能力存在瓶颈。
3. 稳定性和可用性这两个指标很难达到。

### 3.分布式架构的演变
阶段一：单应用架构
阶段二：应用服务器与数据库服务器分离
阶段三：应用服务器集群
阶段四：应用服务器负载客户
阶段五：数据库读写分离
阶段六：添加搜索引擎缓解读库压力
阶段七：添加缓存机制缓解数据库的压力
阶段八：数据库水平/垂直拆分
阶段九：应用拆分
阶段十：服务化

## 2.分布式系统面临的问题
1. 通信异常
   ```text
      网络本身的不可靠性，因此每次网络通信都会伴随着网络不可用的风险
   （光纤、路由、DNS等硬件设备或系统的可不用），都会导致最终分布式系
   统无法顺利进行一次网络通信，另外，即使分布式系统各节点之间的网络通
   信能够正常执行，其延时也会大于单机操作，存在巨大的延迟差别，也会影
   响消息的收发过程，因此消息丢失和消息延迟变得非常普遍。
   ```
2. 网络分区
   ```text
      网络之间出现了网络不连通，但各个子网络内部网络是正常的，从而导致
   整个系统的网络环境被切分成了若干个孤立的区域，分布式系统就会出现局部
   小集群，在极端情况下，这些小集群会独立完成原本需要整个分布式系统才能
   完成的功能，包括数据的事务处理，这就对分布式一致性提出非常大的挑战。
   ```
3. 节点故障
   ```text
      节点故障指的是组成分布式系统的服务器节点出现宕机或僵死的现象，
   根据经验来说，每个节点都有可能出现故障，并且经常发生。
   ```
4. 三态
   ```text
      分布式系统每一次请求与响应存在特有的“三态”概念：成功、失败、超时。
   分布式系统中，由于网络是不可靠的，虽然绝大部分情况下，网络通信能够接
   受到成功或失败的响应，但当网络出现异常的情况下，就会出现超时现象，通
   常有以下两种情况：   
       1. 由于网络原因，该请求并没有被成功的发送到接受方，而是在发送过
          程中发生了丢包现象。
       2. 该请求成功的被接收方接手后，并进行了处理，但在响应反馈给发送
          方过程中，发生了消息丢包现象。
   ```

## 3. 分布式理论：一致性
### 1. 什么是分布式一致性
```text
分布式数据一致性，指的是数据在多份副本中存储时，各副本中的数据是一致的。
```
### 2. 副本一致性
```text
分布式系统有多态机器，每台机器上的数据就是一个副本，集群中每台机器的数据
一致就是副本一致性。
```
### 3. 一致性分类
1. 强一致性
   ```text
   这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也是什么，
   用户体验好，但实现起来往往对系统的性能影响大且很难实现
   ```
2. 弱一致性
   ```text
   这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的数据，也不
   承诺多久之后数据能够到达一致，但会尽可能地保证到某个时间级别（比如秒级）
   后，数据能够达到一致状态。
   ``` 
   1. 读写一致性      
      ```text
      用户读取自己写入结果的一致性，保证用户永远能够第一时间看到自己更像的
      内容。
      
      解决方案：
          1. 对于一些特定的内容我们每次都去主库读取。（导致主库压力大）
          2. 设置一个更新时间窗口，在刚刚更新的一段时间内，我们默认都从主库
             读取，过了这个窗口之后，我们会挑选最近有过更新的从库进行读取。
          3. 我们直接记录用户更新的时间戳，在请求的时候把这个时间戳带上，
             凡是最后更新时间小于这个时间撮的从库都不予响应。
      ```
   2. 单调读一致性
      ```text
      本次读到的数据不能比上次读到的旧。
      由于主从节点更新数据的时间不一致，导致用户在不停刷新的时候，有时候能刷出来，
      再次刷新之后会发现数据不见了，再刷新又有可能再刷出来。
      
      解决方案：
         就是根据用户id计算一个hash值，再通过hash值映射到机器。同一个用户不管怎么
         刷新，都只会被映射到同一台机器上，这样就保证了不会读到其他从库的内容，带来
         用户体验不好的影响。
      ```   
   3. 因果一致性
      ```text
      指的是：如果节点A在更新完某个数据后通知了节点B，那么节点B之后对该数据的访问和
      修改都是基于A更新后的值。与此同时，和节点A无因果关系的节点C的数据访问则没有这
      样的限制。
      ```   
   4. 最终一致性
      ```text
      最终一致性是所有分布式一致性模型中最弱的。可以认为是没有任何优化的“最”弱一致性
      它的意思是说，不考虑所有的中间状态的影响，只保证当没有新的更新之后，经过一段时
      间之后，最终系统内所有副本的数据都是正确的。它最大程度上保证了系统的并发能力，
      也因此，在高并发的场景下，它也是使用最广的一致性模型。
      ```
## 4. 分布式理论：CAP定理
CAP定理
```text
CAP理论含义是，一个分布式系统不可能同时满足一致性（C：Consistency），可用性
（A：Availability）和分区容错性（P：Partition tolerance）这三个基本需求，
最多同时满足其中的两个。
C一致性（Consistency）：分布式系统当中的一致性指的是所有节点的数据一致，或者说是所有副本的数据一致，这种一致性是强一致性
A可用性（Availability）：Reads and writes always succeed。也就是说系统一直可用，而且服务一直保持正常
P分区容错性（Partition tolerance）：系统在遇到一些节点或者网络分区故障的时候，仍然能够提供满足一致性和可用性的服务
```      
      
## 5. 分布式理论：BASE理论
```text
BASE全称是Basically Available（基本可用），Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。
BASE是对CAP中一致性和可用性权衡的结果，BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当
的方式来使系统达到最终一致性。
```
1. Basically Available（基本可用）
   ```text
   基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性--但请注意，这绝不等价于系统不可用。以下有两个例子：
      1.响应时间上的损失：正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，
        查询结果的响应时间增加到1~2秒。
      2.功能上的损失：正常情况下，在一个电子商务网站上购物，消费者几乎能够顺利地完成每一笔订单。但在一些节日大促购物高峰
        的时候，由于消费者的购物行为激增，为了保护系统的稳定性（或一致性），部分消费者可能会被引导到一个降级页面。 
   ```
2. Soft state（软状态）
   ```text
   软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，
   即允许系统在多个不同节点的数据副本之间进行数据同步的过程中存在延迟。
   ```
3. Eventually consistent（最终一致性）
   ```text
   最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此最终一致性的本质是
   需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。
   ```
   
## 6. 分布式理论：一致性协议2PC
### 1，什么是2PC
```text
2PC（Two-Phase Commit缩写）即两个阶段提交协议，是将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段
（commit phase），2是指两个阶段，P是指准备阶段，C是指提交阶段。
```
1. 准备阶段（Prepare phase）
   ```text
   事务管理器给每个参与者发送Prepare消息，每个数据库参与者在本地执行事务，并写本地的Undo/Redo日志，此时事务没有提交。
   （Undo日志是记录修改前的数据，用于数据库回滚，Redo日志是记录修改后的数据，用于提交事务后写入数据文件）
   ```
2. 提交阶段（Commit phase）
   ```text
   如果事务管理器收到了参与者的执行失败或超时消息时，直接给每个参与者发送回滚（Rollback）消息；否则，发送（Commit）消息；
   参与者根据事务管理器的指令执行提交或回滚操作，并释放事务处理过程中使用的所资源。注意：必须在最后阶段释放所资源。
   ```
   
## 7. 分布式理论：一致性协议3PC
```text
3PC，全称“three phase commit”，是2PC的改进版，将2PC的“提交事务请求”过程一分为二，形成了
CanCommit、PreCommit和DoCommit三个阶段组成的事务处理协议。
```
1. 阶段一：CanCommit
2. 阶段二：PreCommit
3. 阶段三：DoCommit

## 8. 分布式理论：一致性算法Paxos
1. Paxos相关概念
   ```text
    首先一个很重要的概念叫提案（Proposal）。最终要达成一致的value就在提案里。
    提案（Proposal）：
       Proposal信息包括提案编号（Proposal ID）和提议的值（Value）
    
    在Paxos算法中，有如下角色：
       Client：客户端
          客户端向分布式系统发出请求，并等待响应。例如，对分布式文件服务器中文件的写请求。
    
       Proposer：提案发起者
          提案者提倡客户请求，试图说服Acceptor对此达成一致，并在发生冲突时充当协调者以推动协议向前发展
    
       Acceptor：决策者，可以批准提案
          Acceptor可以接受提案；如果某个提案被选定，那么提案里的value就被选定了
    
       Learners：最终决策的学习者
          学习者充当该协议的复制因素
    ```
2. Paxos算法的几点要求：
   ```text
    假设有一组可以提出提案的进程集合，那么对于一个一致性算法需要保证以下几点：
       1. 在这些被提出的提案中，只有一个会被选定
       2. 如果没有提案被提出，就不应该有被选定的提案
       3. 当一个提案被选定后，那么所有进程都应该能学习到这个被选定的value
   ```
   
3. Paxos算法的规定
   1. 一个Acceptor必须接受它收到的第一个提案
   2. 一个提案被选定必须被半数以上的Acceptor接受
   3. 如果某个value为v的提案被选定了，那么每个编号更高的被选定的提案value必须也是v
   4. 如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案value必须也是v
   5. 如果某个value为v的提案被选定了，那么之后任何Proposer提出的编号更高的提案value必须也是v
   6. 对于任意的Mn和Vn，如果提案[Mn,Vn]被提出，那么肯定存在一个由半数以上的Acceptor组成的集合S，满足以下两个条件的任意一个：
      + S中每个Acceptor都没有接受过编号小于Mn的提案（少见）
      + S中每个Acceptor批准的所有编号小于Mn的提案中，编号最大的那个提案的value为Vn
      
4. Paxos算法提案生成的规则
   + Proposer生成提案:
       ```text
       1. Proposer选择一个新的提案编号N，然后向某个Acceptor集合（半数以上）发送请求，要求该
          集合中的每个Acceptor做出如下响应（response）：
          a. Acceptor向Proposer承诺保证不再接受任何小于N的提案。
          b. 如果Acceptor已经接受过提案，那么就向Proposer反馈已经接受过的编号小于N的，
             但为最大编号的提案的值。
     
       2. 如果Proposer收到了半数以上的Acceptor响应，那么它就可以生成编号为N，Value为V的提案[N,V]。
          这里的V是所有响应中编号最大的提案的Value。如果所有响应都没有提案，那么此时V就可以由Proposer
          自己选择。生成提案后，Proposer将该提案发送给半数以上的Acceptor集合，并期望Acceptor能够接受该提案。
       
       注：1称之为编号为N的Prepare请求，2称之为Accept请求。     
       ```
     
   + Acceptor接受提案：
      ```text
      1. Prepare请求：Acceptor可以在任何时候响应一个Prepare请求
      2. Accept请求： 在不违背Accept现有承若的前提下，可以任意响应Accept请求
     
      约束：
         一个Acceptor只要尚未响应过任何编号大于N的Prepare请求，那么它就可以接受这个编号为N的提案
      ```
5. Learn学习被选定的value
   1. 方案一：
      ```text
      Acceptor接受一个提案，就将该提案发送给所有Learner。
      
      优点：Learner能快速获取被选定的value
      缺点：通信次数为M*N
      ```     
   2. 方案二：
      ```text
      Acceptor接受了一个提案，就将该提案发送给主Learner，主Learner再通知其他Learner
      
      优点：通信次数少M+N-1
      缺点：单点问题，主Learner挂了，则无法同步提案
      ```
      
   3. 方案三：
      ```text
      Acceptor接受一个提案，就将该提案发送给一个Learner集合，Learner集合再通知其他Learner
      
      优点：集合中Learner个数越多，可靠性越好
      缺点：网络通信复杂度高
      ```
      
6. 保证Paxos算法活性
   ```text
   活性：最终一定会发生的事情，最终一定要选定value
   方案：选取一个住Proposer，只有主Proposer才能提出提案
   ```
   
## 9.分布式理论：一致性算法Raft
```text
Raft是一种为了管理复制日志的一致性算法。
Raft提供了和Paxos算法相同的功能和特性，但是它的算法结构和Paxos不同。
Raft算法更加容易理解并且更容易构建实际的系统。

Raft将一致性算法分为三个模块：
   1.领导人选举
   2.日志复制
   3.安全性

Raft算法分为两个阶段：
   1.先选举领导人
   2.在领导人的带领下进行操作
```
1. 领导人选举
   ```text
   在Raft中，任何时候一台服务器都可以扮演下面角色的其中之一：
      1. 领导者（leader）：处理客户端交互，日志复制等动作，一般一次只有一个领导者
      2. 候选者（candidate）：候选者就是在选举过程中提名自己的实体，一旦选举成功，则成为领导者
      3. 跟随者（follower）：类似选民，完全被动的角色，这样的服务器等待被通知投票，而影响它们身份变化的则是选举
   
   Raft使用心跳机制来触发选举。当Server启动时，初始状态都是follower。每一个server都有一个定时器，
   超时时间为election timeout（150-300ms），如果某个Server没有超时的情况下收到来自领导者或候选者
   的任何消息，则：定时器重启，否则：它就开始一次选举
   ```
   
2. 节点异常
   1. leader不可用：重新选举leader，如果旧leader变的可用，则：旧leader同步数据并变为follower
   2. follower节点不可用或添加follower机器：同步leader数据，然后正常工作
   3. 多个candidate或多个leader：多次投票选举，直到选举出leader为止
   
   
# 2.分布式系统设计策略
1. 心跳检测
2. 高可用设计
3. 容错性
4. 负载均衡 

# 3.RPC
### 1. 什么是RPC
```text
RPC全称为Remote Procedure Call，即远程过程调用。
借助RPC可以做到像本地调用一样调用远程服务，是一种进程间的通信方式。
需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。
```
### 2. RPC架构：
```text
一个完整的RPC架构里面包含了四个核心组件，Client、Client Stub、Server以及Server Stub，
其中Stub可以理解为存根

+ 客户端（Client）：服务的调用方
+ 客户端存根（Client Stub）：存放服务端的地址消息，再将客户端的请求参数打包成网络消息，
     然后通过网络远程发送给服务方。
+ 服务端（Server）：真正的服务提供者。
+ 服务端存根（Server Stub）：接收客户端发送过来的消息，将消息解包，并调用本地的方法。
```

### 3. RMI
```text
Java RMI指的是远程方法调用（Remote Method Invocation），是Java原生支持的远程调用，
采用JRMP（Java Remote Messageing Protocol）作为通信协议，可以认为是纯Java版本的
分布式远程调用解决方案，RMI主要用于不同虚拟机之间的通信，这些虚拟机可以在不同的主机上，
也可以在同一个主机上，这里的通信可以理解为一个虚拟机上的对象调用另一个虚拟机上对象的方法。

1. 客户端：
   1. 存根/桩（Stub）：远程对象在客户端上的代理 
   2. 远程引用层（Remote Reference Layer）：解析并执行远程引用协议
   3. 传输层（Transport）：发送调用、传递远程方法参数、接受远程方法执行结果

2. 服务端：
   1. 骨架（Skeleton）：读取客户端传递的方法参数，调用服务器方的实际对象方法，
          并接受方法执行后的返回值
   2. 远程引用层（Remote Reference Layer）：处理远程引用后向骨架发送远程方法调用
   3. 传输层（Transport）：监听客户端的入站连接，接收并转发调用到远程引用层

3. 注册表（Registry）：
   以URL形式注册远程对象，并向客户端回复对远程对象的引用。
```

# 4.BIO NIO AIO
## 1. 同步和异步
```text
同步（synchronize）、异步（asychronize）是对应用程序和内核交互而言的

同步：
    指用户进程触发IO操作等待或者轮询的方式查看IO操作是否就绪

异步：
    当一个异步进程调用发出之后，调用者不会立刻得到结果。而是在调用发出之后，被调用者通过
状态来通知调用者，或者通过回调函数来处理这个调用。
    使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓存区地址和大小传给OS，OS需要支
持异步IO操作。
```

## 2. 阻塞和非阻塞
```text
阻塞和非阻塞是针对于进程访问数据的时候，根据IO操作的就绪状态来采取不同的方式。

阻塞：
    ATM机排队取款，你只能等待排队取款（使用阻塞IO的时候，Java调用会一直阻塞到读写完成才返回）

非阻塞：
    柜台取款，取个号，然后坐在椅子上做其他事情，等待广播通知，没到你的号你就不能去，但你可以
不断的问大堂经理排到了没有。（使用非阻塞IO时，如果不能读写，Java调用会立刻返回，当IO事件分发
器通知可读写时再继续进行读写，不断循环直到读写完成）
```

## 3. BIO
```text
同步阻塞IO，B代表Blocking。

服务器的实现方式是一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程来处理。
```

## 4. NIO
```text
同步非阻塞IO（non-blocking IO / new IO）指jdk1.4及以上版本。

服务器实现模式为一个请求一个通道，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接
有IO请求时才启动一个线程进行处理。

当一个连接创建后，不会需要对应一个线程，这个连接会被注册到多路复用器上，所以一个连接只需要一个线程即
可，所有连接需要一个线程操作，该线程的多路复用器会轮询发现连接有IO操作请求时，才开启一个线程处理。

通道（Channels）
    NIO新引入的最重要的抽象概念是通道。Channel数据连接的通道，数据可以从Channel读到Buffer中，也可
以从Buffer写到Channel中。

缓冲区（Buffers）
    通道Channel可以向缓存区Buffer写数据，也可以向Buffer中存数据。

选择器（Selector）
    使用选择器，借助单一线程，就可对数量庞大的活动IO通道实施监控和维护
```

## 5. AIO
```text
异步非阻塞IO，A代表asynchronize。

与NIO不同，AIO需要一个连接注册读写时间和回调方法，当进行读写操作时，只需调用API的read和write方法即可。
这两个方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓存区，并通知
应用程序；对于写操作而言，当操作系统将write方法传入的流写入完毕时，操作系统主动通知应用程序。即可以理
解为，read和write方法都是异步的，完成后会主动调用回调函数。

使用场景：连接数目多且连接比较长（重操作）的架构，比如：相册服务器。重点调用了OS参与并发操作，编程比较
复杂。Java7开始支持
```

# 5. Netty
## 1. 什么Netty
```text
Netty就是一个网络通信框架，封装的NIO与AIO

为什么使用Netty？
   NIO缺点：
      1. NIO类库和API复杂，使用麻烦。需要开发者熟练掌握Selector、ServerSocketChannel、
         SocketChannel、ByteBuffer等。
      2. 可靠性不强，开发工作量和难度都非常大
      3. NIO的BUG。例如：Epoll BUG，它会导致Selector空轮询，最终导致CPU 100%
   Netty优点：
      1. 对各种传输协议提供统一的API
      2. 高度可定制的线程模型--单线程、一个或多个线程池
      3. 更好的吞吐量，更低的等待延迟
      4. 更少的资源消耗
      5. 最小化不必要的内存拷贝         
```
